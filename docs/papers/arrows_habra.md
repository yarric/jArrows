# Стрелки как подход к представлению процессов и систем на Java 8 

Часто встречается описание систем, алгоритмов и процессов в виде структурных схем. Как следствие, возникает задача
представления структурных схем, к примеру из технической документации, на каком-либо языке программирования. 

В данной статье мы рассмотрим подход к представлению структурных схем с использованием концепции стрелок (*arrows*), [описанных](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf) Джоном Хьюзом и нашедших применение
в Haskell в FRP-фреймворках [Yampa](https://wiki.haskell.org/Yampa) и [Netwire](http://hackage.haskell.org/package/netwire), 
а также в XML-фреймворке [Haskell XML Toolbox](http://www.fh-wedel.de/~si/HXmlToolbox/index.html).

Особенностью структурных схем является наглядное представление последовательностей операций (блоков) без акцентирования внимания на самих обрабатываемых данных (переменных) и их состояниях. Для примера рассмотрим радиоприёмник прямого усиления

![структурная схема приёмника](https://upload.wikimedia.org/wikipedia/commons/7/72/Tuned_radio_frequency_%28TRF%29_receiver_block_diagram_2.svg)

Как же реализовать такой способ описания систем и вычислений в рамках существующих мейнстримовых 
языков программирования? 

Традиционное описанние такой схемы на C-подобном языке программирования выглядело бы примерно так 

```Java
// Создаём блоки обработки
Antenna antenna = new Antenna(Ether.getInstance());
Filter filter1 = new Filter(5000);      // параметр - частота настройки
Filter filter2 = new Filter(5000);
Filter filter3 = new Filter(5000);

Detector detector = new Detector("AM"); // тип модуляции - амплитудная
Amplifier amp = new Amplifier(5);       // коэффициент усиления
Speaker speaker = new Speaker(10);      // громкость

Signal inputSignal = antenna.receive();

# Описываем связи между блоками
Signal filter1Res = filter1.filter(inputSignal);
Signal filter2Res = filter2.filter(filter1Res);
Signal filter3Res = filter3.filter(filter2Res);
Signal detected = detector.detect(filter3Res);
Signal amplified = amp.amplify(detected);

speaker.speak(amplified);
```

Видно, что в программу добавились переменные, которых не было в структурной схеме, и которые, 
следовательно, не добавляют никакой информации о работе радиоприёмника и нужны лишь для 
хранения промежуточных результатов обработки.

Такая программа, которая описывает лишь простое поэтапное прохождение сигнала через блоки 
обработки, выглядит достаточно сложночитаемо даже без параллельных блоков и обратных связей. 

Более лаконичным подходом будет непосредственное описание схемы с использованием 
дополнительных методов, описывающих соединения блоков без дополнительных переменных:

```Java

Receiver receiver = Receiver.join(filter1).join(filter2).join(filter3)
    .join(detector).join(amp).join(speaker);
    
receiver.apply(antenna.receive());
```

Метод `join()` описывает последовательное соединение блоков, то есть `a.join(b)` означает, что результат 
обработки блоком `a` будет передан на вход блока `b`. При этом лишь требуется, чтобы соединяемые классы `Filter`, `Amplifier`, `Detector`, `Speaker` реализовывали некоторый метод `apply()`, выполняющий "действие по-умолчанию" (для фильтра `Filter` - `filter()`, для `Amplifier` - `amplify()` и т. д.) и позволяющий вызывать объект как функцию.

При функциональном подходе эти классы были бы функциями, возвращающими функции, так что нам не пришлось бы даже создавать экземпляры классов и вся программа выглядела б так:

```Java
Receiver receiver = Receiver.join(filter(1)).join(filter(2)).join(filter(3))
    .join(detector("AM")).join(amplifier(5)).join(speaker(10));
    
receiver.apply(antenna.receive());
```

Параллельное соединение блоков также легко реализовать, например методом `split()`, при этом `a.split(b,c)` 
будет означать, что выход блока `a` будет передаваться на входы блоков `b` и `c`.

## Стрелки как способ описания вычислений
Одной из особенностей функционального подхода является использование комбинаторов, которые являются 
функциями, объединяющими другие функции в составные вычисления. Примером комбинатора являются монады. 
Стрелки (*arrows*) также являются комбинатором и позволяют обобщенно описывать составные вычисления. 
В этой статье используется реализация стрелок [jArrows](https://github.com/yarric/jArrows), написанная 
на Java 8. 

### Что такое стрелка
Стрелка `Arrow<In, Out> a` от функции `Out f(In x)` представляет вычисление, которое выполняется функцией 
`f`. Как вы уже могли догадаться `In` - тип входного значения стрелки (принимаемого функцией `f`), `Out` - тип 
выходного значения (возвращаемого функцией `f`). Преимуществом представления вычислений в виде стрелок является 
возможность явного комбинирования вычислений различными способами.

Например вычисление `y = x * 5.0`, на Java представленное функцией `double multBy5_0(int in) { return in*5.0; }`, можно представить в виде стрелки `Arrow<Integer, Double> arrMultBy5_0 = Action.of(multBy5_0);`. Далее упакованное в стрелку вычисление можно комбинировать с другими вычислениями-стрелками. Класс `Action` является одной из реализаций интерфейса `Arrow`. Другой реализацией этого интерфейса является `ParallelAction`, поддерживающий многопоточные вычисления. 

### Композиция стрелок
Стрелку `arrMultBy5_0` можно последовательно подсоединить к другой стрелке, к примеру прибавляющей к входному
значению 10.5, а затем - к следующей стрелке, представляющей результат в виде строки. Получится цепочка 
из стрелок

```
Arrow<Integer, String> mult5Plus10toStr = arrMultBy5_0.join(in -> in+10.5)
                                                      .join(in -> String.valueOf(in));
mult5Plus10toStr.apply(10);      //  "60.5"                  
```  

Получившееся вычисление, представленное составной стрелкой `mult5Plus10toStr`, можно представить в виде структурной схемы:

![Составная стрелка mult5Plus10toStr](https://github.com/yarric/jArrows/blob/master/docs/papers/images/mult5Plus10toStr.png)

Вход получившейся составной стрелки имеет тип `Integer`, то есть входной тип первого вычисления в цепочке, 
а выход имеет тип `String` - выходной тип последнего вычисления в цепочке.

Метод `someArrow.join(g)` соединяет в цепочку вычисление, представленное стрелкой `someArrow` с вычислением, представленным `g`, при этом `g` может быть другой стрелкой, лямбда-функцией, методом, или чем-то ещё, что реализует интерфейс `Applicable` с методом `apply(x)`, который можно применить к входному значению `x`. 

<Спойлер>Несколько упрощенная реализация `join()`

```Java
class Action<In, Out> implements Arrow<In, Out>, Applicable<In, Out> {
	Applicable<In, Out> func;

    public Arrow<In, OutB> join(Applicable<Out, OutB> b) {
		return Arrow.of(i -> b.apply(this.func.apply(i)));
	}
}
```
где `In` - тип входных данных стрелки `a`, `OutB` - тип выходных данных `b`, 
и он же - тип выходных данных получившейся новой составной стрелки `a_b = a.join(b)`, 
`Out` - тип выходных данных стрелки `a`, он же - тип входных данных стрелки `b`. Функция `func` 
хранится в экземпляре стрелки, инициализируется при её создании и выполняет само вычисление. 
Аргумент `b` поддерживает интерфейс `Applicable` и может быть другой стрелкой или функцией, 
поэтому мы просто применяем `b` к результату применения `a.func(i)` к входным данным `i` 
стрелки `a_b`. Сам входные данные будут переданы при вызове `apply`, так что `a_b.apply(x)` вернёт 
результат вычисления `b.func(a.func(x))`.

</Спойлер>

### Другие способы композиции стрелок
Кроме последовательного соединения методом `join` стрелки можно соединять параллельно методами `combine`, 
`cloneInput` и `split`. Пример использования метода `combine` для описания вычисления `sin(x)^2+cos(x)^2`

```
Arrow<Pair<Double, Double>, Pair<Double, Double>> 
	sin_cos = Arrow.of(Math::sin).combine(Math::cos);

Arrow<Double, Double> sqr = Arrow.of(i -> i*i);

Arrow<Pair<Double, Double>, Double> sum_SinCos = sin_cos.join(sqr.combine(sqr))
							.join(p -> p.left + p.right);

sum_SinCos.apply(Pair.of(0.7, 0.2));    // 1.38

```
![Составная стрелка sum_SinCos](https://github.com/yarric/jArrows/blob/master/docs/papers/images/sum_SinCos.png)

Получившаяся "широкая" стрелка `sin_cos` принимает на вход пару значений типа `Pair<Double, Double>`, первое значение 
`pair.left` пары попадает на вход первой стрелки, второе `pair.right` - на вход второй, их результаты тоже объединяются в пару. Следующая составная стрелка `sqr` принимает на вход значение типа `Pair<Double, Double>`и возводит оба значения пары в квадрат. Последняя стрелка суммирует пару выходных значений стрелки 
sqr.combine(sqr).

`someArrow.cloneInput(f)` создаёт стрелку, параллельно соединяя `someArrow` и `f` и применяя их к входу, 
её выход представляется в виде пары, объединяющей результаты вычилений этих стрелок. Входные типы 
`someArrow` и `f` должны совпадать.

```Java
Arrow<Integer, Pair<Integer, Double>> sqrAndSqrt = Arrow.of(i -> i*i)
							.cloneInput(Math::sqrt); 
sqrAndSqrt.apply(5);  // Pair(25, 2.236)
```
![Составная стрелка sqrAndSqrt](https://github.com/yarric/jArrows/blob/master/docs/papers/images/sqrAndSqrt.png)

Параллельное соединение в данном случае означает, что результат двух вычислений, соединённых параллельно, 
не зависят друг от друга, в отличии от последовательного соединения методом `join`, когда результат одного вычисления передаётся на вход другого. Многопоточные параллельные соединения реализуется классом 
`ParallelAction`.

`someArrow.split(f, g)` - дополнительный метод, эквивалентный `someArrow.join(f.cloneInput(g))`. Результат вычисления `someArrow` параллельно передаётся на вход `f` и `g`, выходом такой стрелки будет пара с результатами вычислений `f` и `g`. 

### Обход вычислений
В некоторых случаях есть необходимость передачи входного значения стрелки далее по цепочке стрелок вместе 
с результатом вычисления этой стрелки. Это реализуется методом `someArrow.first()` и дополняющим его `someArrow.second()`, преобразующим стрелку `someArrow` так, что получившаяся стрелка передаёт на выход пару, содержащую результат вычисления `someArrow` и само входное значение `someArrow`.

```Java
Arrow<Integer, Double> arr = Arrow.of(i -> Math.sqrt(i*i*i));

arr.first().apply(10);     // Pair(31.623, 10)
arr.second().apply(10);    // Pair(10, 31.623)
```

Эти методы аналогичны методам `someArrow.bypass2nd()` и `someArrow.bypass1st()` соответственно. 

## Немного теории

